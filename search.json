[{"title":"ZT 写给朋友的Hexo建站指南，含Coding Pages、域名解析、日常使用","url":"/2019/07/03/ZT:写给朋友的Hexo建站指南，含Coding Pages、域名解析、日常使用/","content":"\n\n\n由来：\n\n一开始是用Jeklly搭的Github Page。后来发现搜索引擎都搜索不到。每次都只有我一个人玩也没啥意思。\n\n然后就找了文章开始在 coding.net 上又搭了套。再加上阿里云买的域名和dns服务。\n\n总的来说。很简单。\n\n这里特别做了个连接多个git的配置。\n\n\n\n有问题联系我，看到会回。\n\n\n\n[写给朋友的Hexo建站指南，含Coding Pages、域名解析、日常使用](https://www.jianshu.com/p/e44b5161ba2c)\n\n[git连接多个远程仓库](https://segmentfault.com/a/1190000011775840)","tags":["Hexo,GitPage"]},{"title":"在docker中搭建mycat&mysql主从集群","url":"/2019/07/01/在docker中搭建mycat&mysql主从集群/","content":"\n\n\n# 在docker中搭建mycat&mysql主从集群\n\n\n\n> 版本信息：\n>\n> Docker:\tDocker Desktop v2.0.0.3 (Engine:18.09.2)\n>\n> MySQL：\t8.0.16\n>\n> MyCat：\t1.6.7\n>\n> 系统： \tMacOs Mojava 10.14.5\t\n\n\n\n## docker安装\n\n我是直接到 [官网 ](https://www.docker.com/products/docker-desktop)下载了个Docker Desktop然后运行就完事了。\n\n> 几个概念：\n>\n> 镜像（image）：就是 docker images 显示的内容。可以理解为安装包（不专业，不要嘲笑我）[点这里可以找镜像](https://hub.docker.com/)\n>\n> 容器：就是 docker ps -a 显示的内容。简单的说可以理解为虚拟机（千万不要真的当成是虚拟机）\n>\n> 随手找了篇文章 [Docker 的一些概念](http://dockone.io/article/6051)。最好去官网看。\n>\n> 附带一个 docker  [简易说明](https://www.runoob.com/docker/docker-image-usage.html)\n\n\n\n## 搭建Mysql主从集群\n\n[[基于Docker的Mysql主从复制搭建](https://www.cnblogs.com/songwenjie/p/9371422.html)](https://www.cnblogs.com/songwenjie/p/9371422.html)\n\n我基本上看着搭的，不过我直接 pull 的最新。没啥问题。除了底下说的几个注意点！\n\n> 这里有说如果碰到问题的第三点，pos 不对，的情况下。在 Master 进入 mysql，执行 show master status。会看到 file 和 position。这里跟主从复制的原理有关系。其实 slave 是根据从 master 拷贝来的日志文件里的指令来实现主从的。这里的 file 指的就是当前的日志文件， position 指读到日志的位置（如果谬误，请指正）。在 change master 这条命令里可以修改 master_log_file 和 master_log_pos 来看看能不能修复问题。这里可能涉及一个命令 reset slave 。\n\n\n\n## 搭建MyCat\n\n推荐一篇文章 [Docker构建MyCat](https://www.jianshu.com/p/4686b123a546) ，排版清晰，主题明了。基本上没啥问题。照着做就行了。\n\n[MyCat 官网](http://www.mycat.io/)\n\n\n\n> 里面的 /usr/local/ 指的是容器里面的路径不是宿主机。整个 DockerFile 只有压缩包是宿主机的内容\n\n\n\n注意最后生成镜像的命令稍微改下就行\n\n```shell\ndocker build -t mycat-1.6.7.1 -f mycat-dockerfile .\n```\n\n\n\n\n\n------\n\n\n\n\n\n### 注意点（T。T 其实就是坑点。至于为什么是坑，我得问问浪费的时间）\n\n1. MySQL 8.* 的远程连接权限\n\n   [mysql8.0.15用户root登录开启远程访问权限](https://blog.csdn.net/liliuqing/article/details/88723409)\n\n   这里特别需要注意的是，MySQL 8 之后修改了加密规则。所以原来的授权命令 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456'  不能用了。\n\n\n\n1. Host（宿主机）的地址\n\n   在 MyCat 的 scheme.xml 文件里以及主从配置的时候需要填写两个 MySQL 的地址。因为我都是装在我自己的电脑上只不过是端口有差异。所以我需要用到宿主机的 IP。因为我电脑上网关实在太多，ifconfig 出来的东西我看着都头大。最后在查到了一段话。\n\n   [Docker初学者问题 - 如何在Docker容器中访问主机（HOST）](https://www.jianshu.com/p/6f20023e4586)。\n\n   [官网文档说明](https://docs.docker.com/docker-for-mac/networking/#use-cases-and-workarounds)。\n\n   > 特别注意：\n   >\n   > 1. 在 docker 引擎 18.03 以后才生效\n   > 2. 我这是 Mac 环境，别的环境没试过\n   > 3. 不建议用于生产","tags":["MySQL Docker MyCat"]},{"title":"数据库事务隔离级别 - 分析脏读 & 不可重复读 & 幻读","url":"/2019/05/30/数据库事务隔离级别：分析脏读 & 不可重复读 & 幻读/","content":"\n\n\n\n\n**阅读目录**\n\n- [一 数据库事务的隔离级别](https://www.cnblogs.com/balfish/p/8298296.html#_label0)\n- [二 不同事务级别带来的并发问题](https://www.cnblogs.com/balfish/p/8298296.html#_label1)\n- [三 例子比较不可重复读和幻读](https://www.cnblogs.com/balfish/p/8298296.html#_label2)\n\n\n\n## 一 数据库事务的隔离级别\n\n数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。\n\n![事物级别](/images/upload/事物级别.png)\n\n### 1. Read UnCommitted(读未提交)\n\n最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。\n\n### 2. Read Committed(读提交)\n\n大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。\n\n### 3. Repeatable Read(重复读)\n\n**mysql的默认级别**。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。\n\n### 4. Serializable(序列化)\n\n最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。\n\n \n\n \n\n \n\n## 二 不同事务级别带来的并发问题\n\n### 1 脏读\n\n脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。这跟不可重复读类似，但是第二个事务不需要执行提交。 \n\n![脏读](/images/upload/脏读.png) \n\n### 2 不可重复读\n\n在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题。\n\n在多版本并行控制机制中，当一个遇到提交冲突的事务需要回退但却被释放时，会发生不可重复读问题。\n\n\n\n![不可重复读](/images/upload/不可重复读.png)\n\n在上面这个例子中，事务2提交成功，它所做的修改已经可见。然而，事务1已经读取了一个其它的值。在序列化和可重复读的隔离级别中，数据库管理系统会返回旧值，即在被事务2修改之前的值。在提交读和未提交读隔离级别下，可能会返回被更新的值，这就是“不可重复读”。\n\n \n\n有两个策略可以防止这个问题的发生：\n\n(1) 推迟事务2的执行，直至事务1提交或者回退。这种策略在使用锁时应用。\n\n(2) 而在多版本并行控制中，事务2可以被先提交。而事务1，继续执行在旧版本的数据上。当事务1终于尝试提交时，数据库会检验它的结果是否和事务1、事务2顺序执行时一样。如果是，则事务1提交成功。如果不是，事务1会被回退。\n\n \n\n \n\n3 **幻读** \n\n幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。\n\n发生的情况：没有范围锁。\n\n![幻读](/images/upload/幻读.png)\n\n \n\n \n\n## 三 例子比较不可重复读和幻读\n\n### 1 不可重复读\n\n不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了\n\n例子:\n\n在事务1中，Mary 读取了自己的工资为1000,操作并没有完成 \n\n```\ncon1 = getConnection();  \nselect salary from employee empId =\"Mary\";  \n```\n\n在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务. \n\n```\ncon2 = getConnection();  \nupdate employee set salary = 2000;  \ncon2.commit(); \n```\n\n在事务1中，Mary 再次读取自己的工资时，工资变为了2000 \n\n```\nselect salary from employee empId =\"Mary\"; \n```\n\n在一个事务中前后两次读取的结果并不致，导致了不可重复读。\n\n \n\n \n\n###  2 幻读\n\n幻读的重点在于新增或者删除 (数据条数变化)。同样的条件, 第1次和第2次读出来的记录数不一样\n\n例子：\n\n目前工资为1000的员工有10人。 \n事务1,读取所有工资为1000的员工。 \n\n```\ncon1 = getConnection();  \nSelect * from employee where salary =1000;  \n```\n\n共读取10条记录 \n\n这时另一个事务向employee表插入了一条员工记录，工资也为1000 \n\n```\ncon2 = getConnection();  \nInsert into employee(empId,salary) values(\"Lili\",1000);  \ncon2.commit();  \n```\n\n事务1再次读取所有工资为1000的员工 \n\n```\nselect * from employee where salary =1000;  \n```\n\n共读取到了11条记录，这就像产生了幻读。 ","tags":["MySQL"]},{"title":"IDEA 快捷键(Win)","url":"/2019/04/15/IDEA快捷键（Windows）/","content":"\n![idea快捷键](/images/upload/idea快捷键.jpg)","tags":["Software"]},{"title":"Mac切换JDK命令(JDK 8/11)","url":"/2019/03/21/MacOs切换JDK命令（JDK811为例）/","content":"\n\n\n1. 官网下载 JDK8 和 JDK11\n\n2. 安装两个版本的jdk完，打开终端查看安装目录所在位置\n\n   > /Library/Java/JavaVirtualMachines/\n\n3. 配置脚本\n\n   在当前用户目录下创建的一个文件：.bash_profile_jdk\n\n   ```shell\n   vim ~/.bash_profile_jdk\n   ```\n\n   配置JDK相关路径和别名\n\n   ```shell\n   # setting jdk8\n   export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`\n   # setting jdk11\n   export JAVA_11_HOME=`/usr/libexec/java_home -v 11`\n   # 默认为JDK8\n   export JAVA_HOME=$JAVA_8_HOME\n   # 切换命令\n   alias jdk8='export JAVA_HOME=$JAVA_8_HOME;export PATH=$JAVA_HOME/bin:$PATH'\n   alias jdk11='export JAVA_HOME=$JAVA_11_HOME;export PATH=$JAVA_HOME/bin:$PATH'\n   #export JAVA_HOME=$(/usr/libexec/java_home)\n   export PATH=$JAVA_HOME/bin:$PATH\n   export CLASS_PATH=$JAVA_HOME/lib\n   ```\n\n   \n\n4. 执行配置文件\n\n   ```shell\n   source ~/.bash_profile_jdk\n   ```\n\n5. 这样基本已经配置执行完毕，进行验证\n\n   终端输入jdk8就行切换jdk8版本，并且查看版本\n\n   ![image-20190322164311879](/images/upload/change-jdk.png)\n\n\n\n-----\n\n找到个新方法：\n\n[SDK Man](https://sdkman.io/)","tags":["Java"]},{"title":"AES_CBC_PKCS5Padding加解密的Java实现","url":"/2019/03/06/AES_CBC_PKCS5Padding加解密的Java实现/","content":"\n\n\n> 这几天碰到用这个来加密数据的接口。特此将代码实现贴上来。\n>\n> 参考资料：[JAVA AES CBC PKCS5Padding加解密](https://www.cnblogs.com/hdwang/p/10286407.html)\n\n> 注：如果需PKCS7Padding。需要另外找两个文件放到jdk目录下。详情百度or谷歌\n\n```java\nimport org.apache.commons.codec.binary.Base64;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\n/**\n *  加密工具类\n */\npublic class AESUtil {\n    private static final Logger logger = LoggerFactory.getLogger(AESUtil.class);\n\n    private static final String KEY_ALGORITHM = \"AES\";\n    private static final String DEFAULT_CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";//默认的加密算法\n\n    /**\n     * AES 加密操作\n     *\n     * @param content 待加密内容\n     * @param password 加密密码\n     * @param iv 使用CBC模式，需要一个向量iv，可增加加密算法的强度\n     * @return 加密数据\n     */\n    public static String encrypt(String content, String password,String iv) {\n        try {\n            //创建密码器\n            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);\n\n            //密码key(超过16字节即128bit的key，需要替换jre中的local_policy.jar和US_export_policy.jar，否则报错：Illegal key size)\n            SecretKeySpec keySpec = new SecretKeySpec(password.getBytes(\"utf-8\"),KEY_ALGORITHM);\n\n            //向量iv\n            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.getBytes(\"utf-8\"));\n\n            //初始化为加密模式的密码器\n            cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivParameterSpec);\n\n            //加密\n            byte[] byteContent = content.getBytes(\"utf-8\");\n            byte[] result = cipher.doFinal(byteContent);\n\n            return Base64.encodeBase64String(result);\n        } catch (Exception ex) {\n            logger.error(ex.getMessage(),ex);\n        }\n\n        return null;\n    }\n\n    /**\n     * AES 解密操作\n     *\n     * @param content 密文\n     * @param password 密码\n     * @param iv 使用CBC模式，需要一个向量iv，可增加加密算法的强度\n     * @return 明文\n     */\n    public static String decrypt(byte[] content, String password,String iv) {\n\n        try {\n            //创建密码器\n            Cipher cipher = Cipher.getInstance(DEFAULT_CIPHER_ALGORITHM);\n\n            //密码key\n            SecretKeySpec keySpec = new SecretKeySpec(password.getBytes(\"utf-8\"),KEY_ALGORITHM);\n\n            //向量iv\n            IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.getBytes(\"utf-8\"));\n\n            //初始化为解密模式的密码器\n            cipher.init(Cipher.DECRYPT_MODE,keySpec,ivParameterSpec);\n\n            //执行操作\n            byte[] result = cipher.doFinal(content);\n\n            return new String(result,\"utf-8\");\n        } catch (Exception ex) {\n            logger.error(ex.getMessage(),ex);\n        }\n\n        return null;\n    }\n\n\n\n}\n```\n\n\n","tags":["Java"]},{"title":"Spring@Transactional注解失效","url":"/2018/11/23/Spring的@Transactional注解失效/","content":"\n\n\n## @Transactional是什么\n\n[@Transacational](https://docs.spring.io/spring/docs/5.0.4.BUILD-SNAPSHOT/javadoc-api/org/springframework/transaction/annotation/Transactional.html) 是Spring框架在1.2版本之后提供的用于管理数据库事物的注解，可用于方法以及类上。\n\n\n\n### 个人理解\n\n其最终实现还是基于JDBC的事物管理：通过切面将由@Transactional管理的方法前后加上JDBC的事物管理，事物失败就在after方法中执行rollback。\n\n\n\n### 特性\n\n先来了解一下@Transactional注解事务的特性吧，可以更好排查问题\n\n1. service类标签(一般不建议在接口上)上添加@Transactional，可以将整个类纳入spring事务管理，在每个业务方法执行时都会开启一个事务，不过这些事务采用相同的管理方式。\n\n2. @Transactional 注解只能应用到 public 可见度的方法上。 如果应用在protected、private或者 package可见度的方法上，也不会报错，不过事务设置不会起作用。\n\n3. 只读事务:\n\n   @Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true) \n   只读标志只在事务启动时应用，否则即使配置也会被忽略。 \n\n4. 默认情况下，Spring会对unchecked异常进行事务回滚；如果是checked异常则不回滚。 \n\n5. 启动事务会增加线程开销，数据库因共享读取而锁定(具体跟数据库类型和事务隔离级别有关)。通常情况下，仅是读取数据时，不必设置只读事务而增加额外的系统开销。\n\n> java里面将派生于Error或者RuntimeException（比如空指针，1/0）的异常称为unchecked异常，其他继承自java.lang.Exception得异常统称为Checked Exception，如IOException、TimeoutException等\n\n> 这里还有一点要注意：如果异常全部被catch了。那就无法触发事物\n\n\n\n\n\n\n### 注意点\n\n1. 在需要事务管理的地方加@Transactional 注解。@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。\n\n2. @Transactional 注解只能应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。\n\n3. 注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据。必须在配置文件中使用配置元素，才真正开启了事务行为。(spring配置文件中,开启声明式事务)\n\n4. 通过 元素的 “proxy-target-class” 属性值来控制是基于接口的还是基于类的代理被创建。如果 “proxy-target-class” 属值被设置为 “true”，那么基于类的代理将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 “proxy-target-class” 属值被设置为 “false” 或者这个属性被省略，那么标准的JDK基于接口的代理将起作用。\n\n5. Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。\n\n6. @Transactional的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个无事务的方法调用另一个有事务的方法，事务是不会起作用的。\n\n\n\n## 解决Transactional注解不回滚\n\n1. 检查你方法是不是public的\n\n2. 你的异常类型是不是unchecked异常。\n\n   如果我想check异常也想回滚怎么办，注解上面写明异常类型即可 @Transactional(rollbackFor=Exception.class) \n\n   类似的还有norollbackFor，自定义不回滚的异常\n\n3. 数据库引擎要支持事务，如果是MySQL，注意表要使用支持事务的引擎，比如innodb，如果是myisam，事务是不起作用的\n\n4. 是否开启了对注解的解析\n\n   ```xml\n   <tx:annotation-driven transaction-manager=\"transactionManager\" \n                         proxy-target-class=\"true\"/>\n   ```\n\n\n5. Spring是否扫描到你这个包，如下是扫描到org.test下面的包\n\n   ```xml\n   <context:component-scan base-package=\"org.test\" />\n   ```\n\n6. 检查是不是同一个类中的方法调用（如a方法调用同一个类中的b方法） \n\n7. 异常是不是被你catch住了\n\n\n\n## 附：事务传播模式\n\nPropagation枚举了多种事务传播模式，部分列举如下：\n\n1. REQUIRED(默认模式)：业务方法需要在一个容器里运行。如果方法运行时，已经处在一个事务中，那么加入到这个事务，否则自己新建一个新的事务。\n\n2. NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。\n\n3. REQUIRESNEW：不管是否存在事务，该方法总汇为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。\n\n4. MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。\n\n5. SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。\n\n6. NEVER：该方法绝对不能在事务范围内执行。如果在就抛例外。只有该方法没有关联到任何事务，才正常执行。\n\n7. NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。\n\n\n\n\n\n\n\n## 参考资料\n\n[@Transactional注解事务不回滚不起作用无效](https://blog.csdn.net/u011410529/article/details/54287307)\n\n[事务传播模式](https://blog.csdn.net/cs2425244259/article/details/50505616)\n\n[spring的service类调用自己方法事务无效](https://blog.csdn.net/qq_34021712/article/details/75949779 )\n\n[Spring 事务失效那点事](https://blog.csdn.net/rylan11/article/details/76609643)","tags":["Java Spring"]},{"title":"VS Code快捷键MacOs版","url":"/2018/11/23/VS Code快捷键（Mac）/","content":"\n### 这篇写的比较好。\n\n---------------------\n作者：D冰城 \n来源：CSDN \n原文：https://blog.csdn.net/d_lds/article/details/63683624 \n版权声明：本文为博主原创文章，转载请附上博文链接！\n\n\n\n---\n\n\n\n### 命令框\n\n1. F1 或 Cmd+Shift+P: 打开命令面板。在打开的输入框内，可以输入任何命令\n   - 在Cmd+P下输入 > 可以进入 Cmd+Shift+P 模式\n2. 在 Cmd+P 窗口下还可以:\n   - 直接输入文件名，跳转到文件\n   - ? 列出当前可执行的动作\n   - : 跳转到行数，也可以 Cmd+G 直接进入\n\n### 常用快捷键\n\n#### 编辑器与窗口管理\n\n1. 打开一个新窗口： Cmd+Shift+N\n2. 关闭窗口： Cmd+Shift+W\n3. 关闭标签页：Cmd+W\n4. 新建文件 Cmd+N\n5. 文件之间切换 Cmd+~\n6. 切出一个新的编辑器（最多 3 个） Cmd+\\\n7. 左中右 3 个编辑器的快捷键 Cmd+1 Cmd+2 Cmd+3\n8. 关闭打开资源管理器 Cmd+B\n9. 切换同一编辑器不同的标签页：control+tab\n\n#### 代码编辑\n\n##### 格式调整\n\n1. 格式化代码：shift+Option+F\n2. 上下移动一行： Option+Up 或 option+Down\n3. 向上向下复制一行： Shift+Option+Up 或 Shift+Option+Down\n4. 在当前行下边插入一行： Cmd+Enter\n5. 在当前行上方插入一行： Cmd+Shift+Enter\n6. 删除当前行：Cmd+Shift+K\n\n##### 光标相关\n\n1. 跳到当前行的头部，尾部：Fn+←，Fn+→\n2. 插入多光标：Option+click或Cmd+Option+up/Cmd+Option+down\n\n#### 搜索和替换\n\n1. 查找：Cmd+F\n2. 将选择添加到下一个查找匹配: Cmd+D\n\n#### 显示\n\n1. 显示搜索：Shift+Cmd+F\n2. 全局替换：Shift+Cmd+H\n3. 放到/缩小：Cmd+=/Cmd+-\n\n#### 扩展\n\n1. 修改语言：组合键Cmd+K M\n2. 设置：Cmd+,\n\n作者：石燕平_Leo\n\n链接：https://www.jianshu.com/p/82136daf07f7\n\n來源：简书\n\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","tags":["Software"]},{"title":"VS Code快捷键Windows版","url":"/2018/11/23/VS Code快捷键（Windows）/","content":"\n## 原文章地址： [vscode: Visual Studio Code 常用快捷键](https://lzw.me/a/vscode-visual-studio-code-shortcut.html)\n\n## 官方快捷键说明：[Key Bindings for Visual Studio Code](https://code.visualstudio.com/docs/customization/keybindings)\n\n \n\n## 主命令框\n\n`F1` 或 `Ctrl+Shift+P`: 打开命令面板。在打开的输入框内，可以输入任何命令，例如：\n\n- 按一下 `Backspace` 会进入到 `Ctrl+P` 模式\n- 在 `Ctrl+P` 下输入 `>` 可以进入 `Ctrl+Shift+P` 模式\n\n在 `Ctrl+P` 窗口下还可以:\n\n- 直接输入文件名，跳转到文件\n- `?` 列出当前可执行的动作\n- `!` 显示 `Errors`或 `Warnings`，也可以 `Ctrl+Shift+M`\n- `:` 跳转到行数，也可以 `Ctrl+G` 直接进入\n- `@` 跳转到 `symbol`（搜索变量或者函数），也可以 `Ctrl+Shift+O` 直接进入\n- `@` 根据分类跳转 `symbol`，查找属性或函数，也可以 `Ctrl+Shift+O` 后输入:进入\n- `#` 根据名字查找 `symbol`，也可以 `Ctrl+T`\n\n## 常用快捷键\n\n### 编辑器与窗口管理\n\n1. 打开一个新窗口： `Ctrl+Shift+N`\n2. 关闭窗口： `Ctrl+Shift+W`\n3. 同时打开多个编辑器（查看多个文件）\n4. 新建文件 `Ctrl+N`\n5. 文件之间切换 `Ctrl+Tab`\n6. 切出一个新的编辑器（最多 `3` 个） `Ctrl+\\`，也可以按住 `Ctrl` 鼠标点击 `Explorer` 里的文件名\n7. 左中右 `3` 个编辑器的快捷键 `Ctrl+1` `Ctrl+2` `Ctrl+3`\n8. `3` 个编辑器之间循环切换 `Ctrl+`\n9. 编辑器换位置， `Ctrl+k`然后按 `Left`或 `Right`\n\n### 代码编辑\n\n#### 格式调整\n\n1. 代码行缩进 `Ctrl+[` 、 `Ctrl+]`\n2. `Ctrl+C` 、 `Ctrl+V` 复制或剪切当前行/当前选中内容\n3. 代码格式化： `Shift+Alt+F`，或 `Ctrl+Shift+P` 后输入 `format code`\n4. 上下移动一行： `Alt+Up` 或 `Alt+Down`\n5. 向上向下复制一行： `Shift+Alt+Up` 或 `Shift+Alt+Down`\n6. 在当前行下边插入一行 `Ctrl+Enter`\n7. 在当前行上方插入一行 `Ctrl+Shift+Enter`\n\n#### 光标相关\n\n1. 移动到行首： `Home`\n2. 移动到行尾： `End`\n3. 移动到文件结尾： `Ctrl+End`\n4. 移动到文件开头： `Ctrl+Home`\n5. 移动到定义处： `F12`\n6. 定义处缩略图：只看一眼而不跳转过去 `Alt+F12`\n7. 移动到后半个括号： `Ctrl+Shift+]`\n8. 选择从光标到行尾： `Shift+End`\n9. 选择从行首到光标处： `Shift+Home`\n10. 删除光标右侧的所有字： `Ctrl+Delete`\n11. 扩展/缩小选取范围： `Shift+Alt+Left` 和 `Shift+Alt+Right`\n12. 多行编辑(列编辑)：`Alt+Shift+鼠标左键`，`Ctrl+Alt+Down/Up`\n13. 同时选中所有匹配： `Ctrl+Shift+L`\n14. `Ctrl+D` 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与 `Ctrl+Shift+K` 互换了)\n15. 回退上一个光标操作： `Ctrl+U`\n\n#### 重构代码\n\n1. 找到所有的引用： `Shift+F12`\n2. 同时修改本文件中所有匹配的： `Ctrl+F12`\n3. 重命名：比如要修改一个方法名，可以选中后按 `F2`，输入新的名字，回车，会发现所有的文件都修改了\n4. 跳转到下一个 `Error` 或 `Warning`：当有多个错误时可以按 `F8` 逐个跳转\n5. 查看 `diff`： 在 `explorer` 里选择文件右键 `Set file to compare`，然后需要对比的文件上右键选择 `Compare with file_name_you_chose`\n\n#### 查找替换\n\n1. 查找 `Ctrl+F`\n2. 查找替换 `Ctrl+H`\n3. 整个文件夹中查找 `Ctrl+Shift+F`\n\n### 显示相关\n\n1. 全屏：`F11`\n2. zoomIn/zoomOut：`Ctrl +/-`\n3. 侧边栏显/隐：`Ctrl+B`\n4. 显示资源管理器 `Ctrl+Shift+E`\n5. 显示搜索 `Ctrl+Shift+F`\n6. 显示 Git `Ctrl+Shift+G`\n7. 显示 Debug `Ctrl+Shift+D`\n8. 显示 Output `Ctrl+Shift+U`\n\n## 其他\n\n- 自动保存：`File -> AutoSave` ，或者 `Ctrl+Shift+P`，输入 `auto`\n\n## 修改默认快捷键\n\n打开默认键盘快捷方式设置：\n`File -> Preferences -> Keyboard Shortcuts`，或者：`Alt+F -> p -> k`\n\n修改 `keybindings.json`：\n\n```json\n// Place your key bindings in this file to overwrite the defaults\n[\n    // ctrl+space 被切换输入法快捷键占用\n    {\n        \"key\": \"ctrl+alt+space\",\n        \"command\": \"editor.action.triggerSuggest\",\n        \"when\": \"editorTextFocus\"\n    },\n    // ctrl+d 删除一行\n    {\n        \"key\": \"ctrl+d\",\n        \"command\": \"editor.action.deleteLines\",\n        \"when\": \"editorTextFocus\"\n    },\n    // 与删除一行的快捷键互换\n    {\n        \"key\": \"ctrl+shift+k\",\n        \"command\": \"editor.action.addSelectionToNextFindMatch\",\n        \"when\": \"editorFocus\"\n    },\n    // ctrl+shift+/多行注释\n    {\n        \"key\":\"ctrl+shift+/\",\n        \"command\": \"editor.action.blockComment\",\n        \"when\": \"editorTextFocus\"\n    },\n    // 定制与 sublime 相同的大小写转换快捷键，需安装 TextTransform 插件\n    {\n        \"key\": \"ctrl+k ctrl+u\",\n        \"command\": \"uppercase\",\n        \"when\": \"editorTextFocus\"\n    },\n    {\n        \"key\": \"ctrl+k ctrl+l\",\n        \"command\": \"lowercase\",\n        \"when\": \"editorTextFocus\"\n    }\n]\n```\n\n## 前端开发必备插件\n\n- PostCSS Sorting\n- stylelint\n- stylefmt\n- ESLint\n- javascript standard format\n- beautify\n- Babel ES6/ES7\n- Debugger for Chrome\n- Add jsdoc comments\n- javascript(ES6) code snippets\n- vue\n- weex\n- Reactjs code snippets\n- React Native Tools\n- Npm Intellisense\n- Instant Markdown\n- Markdown Shortcuts\n- TextTransform\n\n## 自定义设置参考\n\nvscode 自定义配置参考：\n\n```yaml\n{\n    \"editor.fontSize\": 18,\n    \"files.associations\": {\n        \"*.es\": \"javascript\",\n        \"*.es6\": \"javascript\"\n    },\n    // 控制编辑器是否应呈现空白字符\n    \"editor.renderWhitespace\": true,\n    // 启用后，将在保存文件时剪裁尾随空格。\n    \"files.trimTrailingWhitespace\": true,\n    // File extensions that can be beautified as javascript or JSON.\n    \"beautify.JSfiles\": [\n        \"\",\n        \"es\",\n        \"es6\",\n        \"js\",\n        \"json\",\n        \"jsbeautifyrc\",\n        \"jshintrc\"\n    ]\n}\n```","tags":["Software"]},{"title":"CDH权限问题的非最佳解决","url":"/2018/11/20/CDH权限问题的非最佳解决/","content":"\n\n\n\n\n在cloudera里面设置本地运行目录用户设为root解决本地文件读取权限问题。然后再把hdfs内部的权限控制关掉就解决用root用户不能跑spark-shell的问题。虽然不太好。不过学习的时候就不管这么多了。\n\n>临时记录。下次补图\n\n\n![nameNode配置root用户访问权限避免无法读取本地文件](https://upload-images.jianshu.io/upload_images/13709630-3613918cbb5b8de3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![关闭检查HDFS权限使得可以通过root用户启动hdfs](https://upload-images.jianshu.io/upload_images/13709630-d044e8d3ec5b218e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","tags":["BigData CDH"]},{"title":"CombineBeansUtil：方法是用于相同对象不同属性值的合并","url":"/2018/11/20/CombineBeansUtil：方法是用于相同对象不同属性值的合并/","content":"\n\n\n\n\n\n>今天碰到了两个Bean合并的案例。这里保留一份找来的工具类，修改了下。\n>注意：方法是用于相同对象不同属性值的合并\n>\n>```java\n>import java.lang.reflect.Field;\n>import java.lang.reflect.Modifier;\n>\n>/**\n> * Description: 对象合并的工具类\n> *\n> * @author\n> * @date 2018-09-11 上午11:27\n> */\n>public class CombineBeansUtil {\n>\n>\n>    /**\n>     * 该方法是用于相同对象不同属性值的合并<br>\n>     * 如果两个相同对象中同一属性都有值，那么sourceBean中的值会覆盖tagetBean重点的值<br>\n>     * 如果sourceBean有值，targetBean没有，则采用sourceBean的值<br>\n>     * 如果sourceBean没有值，targetBean有，则保留targetBean的值\n>     * \n>     * @param sourceBean    被提取的对象bean\n>     * @param targetBean    用于合并的对象bean\n>     * @return targetBean,合并后的对象\n>     */\n>    public static <T> T combineSydwCore(T sourceBean, T targetBean){\n>        Class sourceBeanClass = sourceBean.getClass();\n>        Class targetBeanClass = targetBean.getClass();\n>\n>        Field[] sourceFields = sourceBeanClass.getDeclaredFields();\n>        Field[] targetFields = targetBeanClass.getDeclaredFields();\n>        for(int i=0; i<sourceFields.length; i++){\n>            Field sourceField = sourceFields[i];\n>            if(Modifier.isStatic(sourceField.getModifiers())){\n>                continue;\n>            }\n>            Field targetField = targetFields[i];\n>            if(Modifier.isStatic(targetField.getModifiers())){\n>                continue;\n>            }\n>            sourceField.setAccessible(true);\n>            targetField.setAccessible(true);\n>            try {\n>                if( !(sourceField.get(sourceBean) == null) &&  !\"serialVersionUID\".equals(sourceField.getName().toString())){\n>                    targetField.set(targetBean,sourceField.get(sourceBean));\n>                }\n>            } catch (IllegalArgumentException | IllegalAccessException e) {\n>                e.printStackTrace();\n>            }\n>        }\n>        return targetBean;\n>    }\n>\n>}\n>\n>```\n\n\n\n\n\n","tags":["Java JavaUtils"]},{"title":"UTC时间和GMT时间","url":"/2018/11/20/UTC时间和GMT时间/","content":"\n\n\n\n\n今天在做一个物联网项目，设备上传的时间是UTC时间。跟我们平时北京时间不通。\n以下是UTC时间的解释：\n\n> UTC是协调世界时(Universal Time Coordinated)英文缩写，是由国际无线电咨询委员会规定和推荐,并由[国际时间局](https://www.baidu.com/s?wd=%E5%9B%BD%E9%99%85%E6%97%B6%E9%97%B4%E5%B1%80&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)(BIH)负责保持的以秒为基础的时间标度。UTC相当于[本初子午线](https://www.baidu.com/s?wd=%E6%9C%AC%E5%88%9D%E5%AD%90%E5%8D%88%E7%BA%BF&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)(即经度0度)上的平均太阳时，过去曾用[格林威治](https://www.baidu.com/s?wd=%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)平均时(GMT)来表示.[北京时间](https://www.baidu.com/s?wd=%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)比UTC时间早8小时，以1999年1月1日0000UTC为例，UTC时间是零点，[北京时间](https://www.baidu.com/s?wd=%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)为1999年1月1日早上8点整。\n\n> 整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与[格林尼治](https://www.baidu.com/s?wd=%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。\n\n> 时差的计算公式：\n> UTC + 时区差 = 本地时间\n> 时区差东为正，西为负（比如东八区记为+0800，西五区记为-0500）\n\n附一张时区对比图片\n![image.png](https://upload-images.jianshu.io/upload_images/13709630-86cadc6e1b301f81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n参考文章：\nhttps://blog.csdn.net/one_girl/article/details/78711240","tags":["Java"]},{"title":"从java.lang.String#intern说起JDK6之前和JDK7及之后关于字符串常量池的区别","url":"/2018/11/20/从java.lang.String#intern说起JDK6之前和JDK7及之后关于字符串常量池的区别/","content":"\n\n\n\n\n# 字符串常量池\n首先，记录一点：\n> 字符串池的确切位置没有被指定，并且可以从一个JVM实现到另一个不同。\n> 值得注意的是，在Java 7之前，该池位于热点JVM上的堆的permgen空间中，但[自Java 7以来它已被移至堆的主要部分](http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html#jdk7changes)。而在Java 8 Hotspot中，Permanent Generation已被彻底删除。\n\n> **区域**：HotSpot **概要**：在JDK 7中，interned字符串不再分配在Java堆的永久生成中，**而是分配在Java堆的主要部分**（称为年轻人和老年人）以及其他人由应用程序创建的对象。此更改将导致更多数据驻留在主Java堆中，永久生成中的数据更少，因此可能需要调整堆大小。由于这种变化，大多数应用程序在堆使用中只会看到相对较小的差异，但是加载很多类或大量使用String.intern（）方法的较大应用程序将会看到更显着的差异。RFE：6962931\n\n# java.lang.String#intern\n然后。这个方法在jdk1.6与idk1.7之后发生了变化。主要是因为jdk1.7之后，方法区中字符串常量池的位置从方法区变成了堆上，intern()方法也做了相应的修改。\n(注：jdk1.8已经移除了方法区，取而代之的是元空间)\n我们看下API：\n![java.lang.String#intern.png](https://upload-images.jianshu.io/upload_images/13709630-9871b7df373eabbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n> 翻译一下，String类的intern()方法：一个初始为空的字符串池，它由类String独自维护。当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。 对于任意两个字符串s和t，当且仅当s.equals(t)为true时，s.intern() == t.intern()才为true。所有字面值字符串和字符串赋值常量表达式都使用 intern方法进行操作。\n\n# 例子\n```java\nString s = new String(\"1\");  \ns.intern();  \nString s2 = \"1\";  \nSystem.out.println(s == s2);  \n\t\t  \nString s3 = new String(\"1\") + new String(\"1\"); \ns3.intern();  \nString s4 = \"11\";  \nSystem.out.println(s3 == s4);   \n```\n如果是JDK6- ，那么运行的结果是false，false。\n如果是JDK7+，运行的结果是false，true。\n\n# 分析\n## JDK6\n\n先针对jdk1.6来分析。intern()方法在jdk1.6中的工作原理是：\n\nString s = new String(\"aaa\");s.intern();在常量池中寻找常量“aaa”,如果存在，则返回这个池中的字符串，如果不存在，将s指向的堆上的对象“aaa”复制后存在常量池中，并返回池中“aaa”的一个引用（这其实说明了运行时常量池具有动态性）。\n\n按照上面的描述开始进行分析。\nString s = new String(\"1\"); \n这句话实际创建了两个对象，一个是常量池中的字符串常量“1’”，另一个是堆上的String对象，s是它的引用。\n\ns.intern(); \n>这一句在池中寻找“1”,可以找到。所以池中没有发生改变。\n\nString s2 = \"1\";  \n>在池中寻找“1”，可以找到，所以s2指向池中“1”\n\n所以运行之后s指向堆中对象，s2指向池中对象，当然不是指向同一个对象，结果为false.\n\n继续往下看\n\nString s3 = new String(\"1\") + newString(\"1\"); \n>这句话执行之后，s3指向堆上值为“11”的一个对象，池中有“1”,但是没有“11”.\n\ns3.intern()； \n>在池中寻找“11”，没有找到，所以在池中添加了“11”\n\nString s4 = \"11\"；\n>在池中寻找“11”，能够找到，所以s4指向了池中的“11”\n\n所以运行后，s3指向堆中的对象，s4指向池中对象，结果为false.\n\n\n## JDK7\n\n再来针对jdk1.7进行分析。\n字符串常量池的位置从方法区变成了堆上。jdk1.7中intern()工作原理：\n\nString s = new String(\"aaa\");\ns.intern(); \n>在常量池中寻找“aaa”,如果已经存在，则返回池中“aaa”这个对象。如果不存在，那么不会在常量池中复制一份s指向的对象“aaa”，而是在常量池中记录了首次出现的对象引用。假设这个引用叫p，p与s指向了堆上同一个对象，即p = s。\n\n根据上面的描述，开始进行逐句分析。\n\nString s = new String(\"1\"); \n>这句话实际创建了两个对象，一个是常量池中的字符串常量“1’”，另一个是堆上的String对象，s是它的引用。\n\ns.intern(); \n>这一句在池中寻找“1”,可以找到。所以池中没有发生改变。\n\nString s2 = \"1\";  \n>在池中寻找“1”，可以找到，所以s2指向池中“1”\n\n所以运行之后s指向堆中对象，s2指向池中对象，当然不是指向同一个对象，结果为false.\n这一部分与jdk1.6版本运行的结果是一样的，因为intern()查找的字符串在常量池中都已经存在了。\n\n继续往下看\n\nString s3 = new String(\"1\") + newString(\"1\"); \n>这句话执行之后，s3指向堆上值为“11”的一个对象，池中有“1”,但是没有“11”.\n\ns3.intern();\n>在常量池中寻找“11”，没有找到，此时不是在常量池中添加“11”，而是在常量池中添加一个堆上“11”对象的引用，假设这个引用叫p,p = s3.intern()。p和s3指向的是堆中的同一个对象，p = s3。\n\nString s4 = \"11\". \n>在常量池中寻找“11”这个对象，发现p指向的对象正是“11”,那么s4也指向了堆上的“11”对象。\n\n那么s3与s4最后都指向了堆上的“11”对象，所以s3 = s4.\n\n# 思考\n``` java\nString s = new String(\"1\");  \ns.intern();  \nString s2 = \"1\";  \nSystem.out.println(s == s2);  \n\t\t\nString s4 = \"11\";  \nString s3 = new String(\"1\") + new String(\"1\"); \ns3.intern();  \nSystem.out.println(s3 == s4);   \n```\n这个的结果是什么，为什么？\n\n参考：[String.intern()方法](https://blog.csdn.net/xdugucc/article/details/78202667)","tags":["Java"]},{"title":"Spring MVC下对Request请求中日期字符串转换成Date类型的总结","url":"/2018/11/20/Spring MVC下对Request请求中日期字符串转换成Date类型的总结/","content":"\n\n\n\n\n\n\n# 背景\n\n>先介绍一下背景：\n>做了几个接口接受数据，同时每个接口都会有日期字段。我发现每个接口的日期格式都略微有些不同。所以需要对不同的接口日期进行转换。\n\n# 可行性\n开篇明义的说一下可以使用的方法：\n1. 首先是最基础的。可以将dateStr拿到String类型。然后转换成Date类型。\n\n2. 其次使用@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)注解在实体字段上。这种方式的优点是：可以灵活的定义接收的类型；缺点很明显：不能全局统一处理，需要为每个需要转换字段都加注解太麻烦。提示：@DateTimeFormat注解还有别的参数。有一些通用的格式以供快速使用。\n\n3. 在controller中写一个binder（我自己叫绑定器）在binder方法上加上@InitBinder注解就可以将传入这个controller的参数转换。这个不止能够转换日期格式，其实基本上什么都能转一下。\n\n~~~java\n    \n\t/**\n     * 绑定一个日期转换, 将UTC字符串转为date类型\n     * @param binder\n     */\n    @InitBinder\n    public void initBinder(WebDataBinder binder){\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\");\n        simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        binder.registerCustomEditor(Date.class, new CustomDateEditor(simpleDateFormat, false));\n    }\n\n~~~\n4. 自定义DateConverterConfig重写convert方法。实现一下spring提供的Converter，重写里面的convert方法：\n\n~~~java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.stereotype.Component;\n\n/**\n * 全局handler前日期统一处理\n * @author wanghh\n * @date 2018/1/11\n */\n@Component\npublic class DateConverterConfig implements Converter<String, Date> {\n\n    private static final List<String> formarts = new ArrayList<>(4);\n    static{\n        formarts.add(\"yyyy-MM\");\n        formarts.add(\"yyyy-MM-dd\");\n        formarts.add(\"yyyy-MM-dd HH:mm\");\n        formarts.add(\"yyyy-MM-dd HH:mm:ss\");\n    }\n\n    @Override\n    public Date convert(String source) {\n        String value = source.trim();\n        if (\"\".equals(value)) {\n            return null;\n        }\n        if(source.matches(\"^\\\\d{4}-\\\\d{1,2}$\")){\n            return parseDate(source, formarts.get(0));\n        }else if(source.matches(\"^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2}$\")){\n            return parseDate(source, formarts.get(1));\n        }else if(source.matches(\"^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} {1}\\\\d{1,2}:\\\\d{1,2}$\")){\n            return parseDate(source, formarts.get(2));\n        }else if(source.matches(\"^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} {1}\\\\d{1,2}:\\\\d{1,2}:\\\\d{1,2}$\")){\n            return parseDate(source, formarts.get(3));\n        }else {\n            throw new IllegalArgumentException(\"Invalid boolean value '\" + source + \"'\");\n        }\n    }\n\n    /**\n     * 格式化日期\n     * @param dateStr String 字符型日期\n     * @param format String 格式\n     * @return Date 日期\n     */\n    public  Date parseDate(String dateStr, String format) {\n        Date date=null;\n        try {\n            DateFormat dateFormat = new SimpleDateFormat(format);\n            date = dateFormat.parse(dateStr);\n        } catch (Exception e) {\n\n        }\n        return date;\n    }\n\n}\n~~~\n\n\n\n\n>参考文章：\n>[spring Boot实践--前端字符串日期自动转换成后台date类型](https://my.oschina.net/spinachgit/blog/1806459)","tags":["Java Spring"]},{"title":"通过 Jekyll 建立网站并发布在 Github Pages","url":"/2018/11/20/通过Jekyll建立网站并发布在Github Pages/","content":"\n\n\n> 弄了半天，总算弄好了。试了好几个模板，最终选了[H20](https://github.com/kaeyleo/jekyll-theme-H2O) 。简洁明了，该有的都有了。也推荐大家使用。\n>\n> 预备知识：Git、Markdown、一点点前段技能\n\n![刚搭完的样子](/images/upload/blog-view.png)\n\n\n\n## 什么是[Github Pages](https://pages.github.com/)\n\nGithub Page本质上是一个在你Github上的一个仓库。Github很有爱的会将与你用户名同名的项目发布一个静态见面，用来分享想法和代码。\n\n> [图片来源自网络](https://www.cnblogs.com/jackyroc/p/7681938.html). 鸣谢@[JackyRoc](https://home.cnblogs.com/u/jackyroc/)\n\n### 创建仓库\n\n在Github首页右上角头像左侧加号点选择 New repositor(新存储库)或[点击这里](https://github.com/new)进行创建一个仓库.\n\n![创建仓库](/images/upload/create-repository.png)\n\n\n\n### 开启Github Pages\n\n进入设置\n\n![进入设置](/images/upload/to-setting.png)\n\n\n\n找到这一块\n\n![设置](/images/upload/setting.png)\n\n当你的仓库名为：用户名.github.io 之后默认开启Github Pages\n\n现在随便选择一个主题,选择上图的 Choose a theme 之后会跳转到下面这个页面\n\n![选择主题](/images/upload/theme.png)\n\n设置完毕后你就可以通过 username.github.io (username为你的用户名访问你的博客了)\n\n \n\n## 个性化Github Pages\n\nGithub Pages有各种个性化方式。记住本质：展示静态页面。所以只要是能生成静态的方式都可以选用。\n\n在今天建站的过程中我找到两种 Hexo 以及 Jekyll。可以自己写也可以在别人的代码上改。Github上有很多项目。不过我在今天的使用中，作为一个非专业前端，一个个需要的环境装过来花了好久。最后火大、干脆fork了一份代码。然后在上面改。还省了编译的过程。我认为这是最简单的方法。\n\n还有好些其他功能，比如自定义域名什么的。我暂时不搞，所以没有去研究。\n\n\n\n隆重推荐我使用的主题：[H20](https://github.com/kaeyleo/jekyll-theme-H2O)\n\n\n\n### 使用H2O模板\n\n大体上的设置就不说了，基本上在他的项目里都有写。耐心阅读即可。现在说下有两点没提到的。\n\n##### 修改仓库信息\n\nfork过来以后，在仓库的setting中，将Repository name改为以username.github.io (username为你的用户名)。如果原来已经存在了这个仓库，可以改掉或者删掉。\n\n##### 一开始fork过来找不到页面\n\n这时候只需要在_config.yml中配置站点\n\n```yaml\n# Site settings 配置站点\ntitle: 'waVeLou的Blog'\ndescription: 'too young，too simple，sometimes naive'\nkeyword: 'wavelou java'\nurl: 'https://wavelou.github.io/' # your host\n```\n\n##### 上传文章\n\n在_posts文件夹中的md文件就是你的文章。但是命名格式有严格要求（年-月-日-title）。\n\n在文章的一开头有一段信息要注意修改:\n\n```yaml\n---\nlayout: post\ntitle: '通过 Jekyll 建立网站并发布在 Github Pages'\ndate: 2018-11-20\nauthor: Wave Lou\ntags: Jekyll GithubPage\n---\n```\n\n图片放在 assets/img/ 底下就能找到。\n\n写完以后上传到Github即可。\n\n\n\n\n\n暂时想到就这么多。准备下班~","tags":["Jekyll GitPage"]}]